2020-04-10 수업 정리

1교시

[복습 시간]

변수
	데이터를 저장!할 수 있는 메모리 공간을 할당한다
	만들어진 메모리에 접근할 수 있는 방법을 제공.
	데이터를 저장하고 나중에 참조하거나 또 다시 저장을 하기 위함
	특정 데이터를 한 번 사용하고 끝나는 것이 아닌 다른 곳에서 사용하기 위함

	선언방법
	int (자료형)  num(식별자,대소문자 구별. 여러가지 조건을 확인 해보자.);

자료형이란?

	변수의 메모리 공간 특징을 정의

자료형을 결정하는 방법
	어떤 종류의 데이터인가? 
	얼마만큼의 범위를 표현하게 할 것인가?(사이즈)

자료형의 종류와 구분
	boolean	true, false		1byte
	char	모든 유니코드 문자	2byte
	byte	-128~127		1byte
	short	-32768 ~ 32767		2byte
	int	-21억~21억		4byte
	long				8byte
	float				4byte
	double				8byte



	
	리터럴 데이터 공간에 저장, int 형으로 변경 됨

키워드 내역들 확인
	소문자

	
정수 표현
	가장 왼쪽 비트는 부호를 타나냄.
	
실수 표현
	정확한 연산 목적보다는 명확도 기준.(부동 소수점 표기.)

문자 표현
	유니코드로 저장.

변수의 기본값과 초기화
	목록 표 확인
	char c= ''; 불가능.  띄어쓰기라도 들어가야 함
	String s = ""; 가능.

문자와 문자열 연산
	계산 순서는 왼쪽부터
	문자열을 만나면 문자열 형태로 변경

형변환
	접미사
		int num1 = 1000000000;
		1000000000에 해당하는 텍스트를 그냥 읽어오는 것이 아닌
		리터럴(int타입 기준) 형태로 메모리에 저장된다.
		
		실수의 경우에는 double 타입 기준.
		float num2 = 12 . 45 F;

자료형을 일치시켜야 하는 이유
	1 + 1.0의 경우 2.0이 나와야 하지만 그렇지 않음을 볼 수 있다.
	그러므로 연산시에는 꼭 자료형을 맞춰주자. 

자동 형 변환 규칙
	1 + 1.0과의 오류로 인한 자료형의 자동 형 변환 규칙
	목록표 꼭 확인하기
명시적 형 변환 
	자동 형 변환 규칙 목록표에서 반대 방향

★어떤 데이터를 어떤 목적으로, 어떤 표현 범위를 가져야 할 것인가를 상황,필요에 맞게 잘
선언할 수 있어야 한다.(주로 정수-int 실수-double 문자-char 논리-boolean 등..)
★데이터들의 연산에 맞는 변수 선언을 할 수 있다.(형변환 숙지)




2교시

[연산자]
	어떠한 기능을 수행하는 기호(+,-,*,/ 등..)
	어떤 것을 연산 하는가? Data.
	대표적으로 숫자 = > 사칙 연산 (비트 단위 연산이므로 주의)
	true/false와 같은 논리연산
	관계 연산 (비교)
	

	피연산자
	연산자의 작업 대상 (변수 ,상수 , 리터럴 , 수식)

단항 연산자 ++ -- + - ~(비트연산) !(논리부정)  (타입) (형변환 연산자) 
산술 연산자 사칙연산 , %(나머지)
비교 연산자 < , > , <= , >= , instance of(객체 -> 상속) , == , !=
논리 연산자 & , ^ , \ , && , \\
-----------------이항 연산자---------------------
삼항 연산자 ?:
대입 연산자 = += /= %= += -= <<= 등...

단항 여산자와, 대입 연산자는 연산 방향이 다르다.

연산자의 우선순위
1. 괄호의 우선순위가 제일 높다.(수학적 개념과 같음)
2. 산술 > 비교 > 논리 > 대입 ex)a + b > b + c의 경우 +의 산술연산을 먼저.
3.단항 > 이항 > 삼항
4.연산자의 연산 진행방향은 외쪽에서 오른쪽이다.
단, 다항 , 대입 연산자만 오른쪽에서 왼쪽이다. 


<< , >>, >>>는 덧셈 연산자보다 우선순위가 낮다.
||(OR)는 &&(AND) 보다 우선순위가 낮다

피 연산자가 정수면 정수형 연산 진행
피 연산자가 실수면 실수형 연산 진행 , 단 %연산자 제외
% 연산자 . 홀수 짝수 등 배수검사에 주로 사용.

10%8 =>2
10%-8 =>2
-10%8 =>-2
-10%-8 => -2



복합 대입 연산자
	Ex) int num =1;
	    num = num + 1;
	    (num에 2가 저장된다.)
	    산술 연산의 경우 우선순위가 높아서, 기존의 num =1값을 가져와서 먼저 산술을 하고,
	    대입 연산자를 통해 그 값을 다시 num에 저장한다.
	Ex) sum = sum +b ========> sum += b     와 같이 표기한다.

관계(비교) 연산자
	조건에 따른 시스템의 방향을 지정해 줄 수 있다.(비교)
	비교의 목적으로 사용 되므로 if 문 for문 while 문 등에 사용된다.
	결과 값은 true 또는 false 이다.
	Ex) x>y . x가 y보다  크다면 true, 그 외에는 false
	기본형(boolean 제외)과 참조형에 사용할 수 있으나,
	참조형에는 ==와 !=만 사용할 수 있다. ( 참조형에는 주소값이 저장되므로 주소값을 비교한다)
	예제
	10.0d == 10.0f  ->   10.0d ==10.0d ----> true
	0.1d == 0.1f    ->    0.1d == 0.1d ----->false (표현되는 변화의 범위가 달라서 다른 숫자이므로)
	(float)0.1d == 0.1f  ->   0.1f == 0.1f     -> true



논리연산자
	OR연산자(||) : 피연산자 중 어느 하나라도 true 라면 결과값은 true 이다.
	AND연산자(&&) : 피연산자 모두 true 여야만 결과값은 ture이다.
	중요도 : OR연산자 < AND연산자
	논리부정연산자(!) : true 는 false 로 , false 는 true로 변경
	논리연산자는 보통 범위를 이용할 때 
	

논리 연산자와 SCE
	Short-circuit Evaluation
	Java는 &&연산에서 앞 수식이 false 이면 물어볼 것도 없이 뒷 수식을 연산하지 않는다.
	
		||연산에서 앞 수식이 true 이면 물어볼 것도 없이 결과값은 true.

이항연산자의 특징
	이항연산자는 연산을 수행하기 전에 피연산자의 타입을 칠일치시킨다.
	int 보다 크기가 작은 타입은 int로 표현한다.
	byte + short -> int + int = int
	char + int -> int +int = int
	float +int -> float + float = float
	long + float -> float + float = float
	float + double -> double +double = double


	!!!Ex
	byte a=10;
	byte b=20
	byte c = a+b; 
	byte c = (byte)a+b; // 에러. 왜냐하면 연산시 정수는 int 형태로 변화 되기 때문에 int형은
				byte형 안으로 들어갈 수 없다.
	그러므로 
	byte c =(byte)(a+b) // OK!

	
	long a = 1000000*1000000; //a는 오류! 왜냐하면 결과값 또한 int 형이므로 다 담을 수 없기 때문에 왜곡이 생긴다
	long b = 1000000*1000000L; // 성공.왜냐하면 앞에 1000000이 long 형으로 자동 형변환 되기 때문이다.

	char c1 = 'a'
	char c2 = c1 + 1 //에러 왜냐하면 연산 시 c1 또한 int형으로 변환 되며 , 결과값이 int 형이므로 char 형태에 들어갈 수 없다.
	char c2 = (char(c1+1)); //가능!
	char c2 = ++c1;  //가능! 단항연산자의 경우에는 char 형을 유지한다.
	int i = 'B' - 'A'; //가능
	int i = '2' - '0'; //가능 연산 시 모두 int 형으로 변환되기 때문에.
	+
	float pi = 3.141592f;
	float shortPi   = (int)(pi*1000) / 1000f;
			= (int)(3.141592f * 1000) / 1000f
			= (int)(3141.592) / 1000f
			= 3141 / 1000f
			= 3.141

	Math.round() 소수점 첫째자리에서 반올림한 값을 반환
	float pi = 3.141592f;
	float shortPi   = Math.round(pi*1000) / 1000f
			= Math.round(3.141592f*1000) / 1000f
			= math.round(3141.592f) / 1000f
			= 3142.0f/1000f
	   		= 3.142f


증감 연산자
	전위형 과 후위형 비교
	++num , num++
	전위형 : 먼저 수를 증가, 증가 이후 값 대입
	후위형 : 먼저 값을 대입하고 증가시킨다.


정리
	여러가지 배웠고 그 이유는 우리가 직접 수식을 만들고 원하고자 하는 답을 얻기 위함이다.
	그러기 위해서는 연산자의 종류, 연산자의 우선 순위,연산 과정, 연산의 결과를 잘 숙지하고 있어야한다.

	


